import java.util.*;

public class Solution {
    public static boolean validStackPermutation(ArrayList<Integer> first, ArrayList<Integer> other){
        // Write your code here.

        Stack<Integer> stack = new Stack<>();
        int n = first.size();

        int j = 0;
        for(int i = 0; i < n; i++){
            stack.push(first.get(i));

            while(!stack.isEmpty() && (stack.peek().equals(other.get(j)))){
                stack.pop();
                j++;
            }
        }

        if(stack.isEmpty() && j == n){
            return true;
        }
        return false;
    }
}

You have been given two arrays having an equal number of elements. You have to find whether one array is the valid stack permutation of the other. An array is said to be a valid stack 
permutation of the other if and only if after applying some push and pop operations onto the sequence of elements in that array, will result in the other array.

Example:
first = [2, 4, 6]
other = [4, 6, 2]

Step 1: i = 0

Push first[0] = 2
âž¡ï¸ stack = [2]
Now check while condition:
stack.peek() == other[j] ?
2 == 4 ? âŒ


No â†’ stop the while loop.
âœ… Current state:
stack = [2], j = 0


ðŸ”¹ Step 2: i = 1
Push first[1] = 4
âž¡ï¸ stack = [2, 4]
Now check while condition:
stack.peek() == other[j] ?
4 == 4 ? âœ…
â†’ Pop from stack â†’ stack = [2]
â†’ j++ â†’ j = 1

Check again:

stack.peek() == other[j] ?
2 == 6 ? âŒ
Stop.

âœ… Current state:
stack = [2], j = 1


ðŸ”¹ Step 3: i = 2
Push first[2] = 6
âž¡ï¸ stack = [2, 6]
Check while condition:
stack.peek() == other[j] ?
6 == 6 ? âœ…
â†’ Pop â†’ stack = [2]
â†’ j++ â†’ j = 2

Now check again:
stack.peek() == other[j] ?
2 == 2 ? âœ…
â†’ Pop â†’ stack = []
â†’ j++ â†’ j = 3

âœ… Current state:
stack = [], j = 3

âœ… Final Check

After the loop:

stack.isEmpty() && j == n ?
true && 3 == 3 ? âœ…


âœ… Result: YES (true)
So [4, 6, 2] is a valid stack permutation of [2, 4, 6].


T.C => O(N)
S.C => O(N)
